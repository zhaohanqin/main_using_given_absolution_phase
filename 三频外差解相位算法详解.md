# 三频外差解相位算法详解

## 一、概述

结构光三维重建中，相位解包裹是关键步骤之一。`get_abs_phase.py`文件实现了基于多频率（三频）外差法的相位解包裹算法，该方法能有效解决单频相位解包裹中的相位跳变和歧义问题。本文将详细解析该算法的原理和实现过程。

## 二、N步相移算法获取包裹相位

### 1. N步相移原理

N步相移算法是一种常用的相位测量技术，通过投影多个具有已知相位偏移的条纹图案，计算出每个像素点的包裹相位（wrapped phase）。包裹相位的值域为[0, 2π]或[-π, π]，存在2π的周期性模糊。

对于N步相移，投影的N张图像光强分布满足：

$$I_i(x,y) = A(x,y) + B(x,y)\cos(\phi(x,y) + \delta_i)$$

其中：

- $I_i(x,y)$ 是第i张图像在(x,y)点的光强
- $A(x,y)$ 是背景光强（偏移量）
- $B(x,y)$ 是调制幅值
- $\phi(x,y)$ 是待求解的相位
- $\delta_i$ 是已知的相位偏移，通常为 $\delta_i = 2\pi i / N$

### 2. 代码实现

`decode_phase`方法实现了N步相移算法：

```python
def decode_phase(self,image):
    """
    N步相移算法解码相位
    
    使用正弦和余弦项计算相移图像的包裹相位，并计算幅值和偏移量
    
    参数:
        image: ndarray，相移图像组，形状为[step, height, width]
        
    返回:
        result: ndarray，归一化的包裹相位图
        amp: ndarray，调制幅值
        offset: ndarray，亮度偏移
    """
    # 生成相移角度数组(0,2π/N,4π/N...)
    temp = 2*np.pi*np.arange(self.step,dtype=np.float32)/self.step
    temp.shape=-1,1,1  # 调整形状以便于广播运算
    
    # 计算正弦项(分子)和余弦项(分母)
    molecule = np.sum(image*np.sin(temp),axis=0)      # 正弦项
    denominator=np.sum(image*np.cos(temp),axis=0)     # 余弦项

    # 使用arctan2计算相位，保证相位值在[-π,π]范围内
    result = -np.arctan2(molecule,denominator)
    
    # 计算调制幅值和亮度偏移
    amp = 2/self.step*molecule        # 调制幅值
    offset = 2/self.step*denominator  # 亮度偏移

    # 归一化相位至[0,1]区间并减去初始相位
    result = (result+np.pi)/(2*np.pi)-self.ph0

    return result,amp,offset
```

关键步骤解析：

1. **相移角度计算**：根据步数N（通常为3或4）生成相位偏移数组
2. **正弦和余弦项计算**：使用公式计算包裹相位的正弦和余弦项
   - 正弦项：$\sum_{i=0}^{N-1} I_i \sin(\delta_i)$
   - 余弦项：$\sum_{i=0}^{N-1} I_i \cos(\delta_i)$
3. **相位计算**：使用反正切函数arctan2计算包裹相位：$\phi = -\arctan2(\text{正弦项}, \text{余弦项})$
4. **相位归一化**：将[-π, π]范围的相位归一化到[0, 1]区间，并减去初始相位偏移

## 三、三频外差法解包裹算法

### 1. 外差法相位解包裹原理

包裹相位由于2π的周期性，无法确定绝对相位值。外差法通过使用不同频率的条纹图案，利用频率差来解决相位歧义问题。

对于频率为f的条纹，其绝对相位 $\Phi$ 与包裹相位 $\phi$ 的关系为：

$$\Phi = \phi + 2\pi k$$

其中k是整数，表示条纹序数。

当使用两个不同频率f₁和f₂（f₁>f₂）的条纹图案时，对应的绝对相位为：

$$\Phi_1 = \phi_1 + 2\pi k_1$$
$$\Phi_2 = \phi_2 + 2\pi k_2$$

由于同一点的实际物理位置相同，满足比例关系：

$$\frac{\Phi_1}{f_1} = \frac{\Phi_2}{f_2}$$

利用这个关系，可以求解出条纹序数k₁和k₂。

三频外差法则使用三个不同频率的条纹图案，通过两级展开过程提高解包裹的鲁棒性。

### 2. 代码中的三频外差法实现

`get_phase`方法实现了完整的三频外差解包裹过程：

```python
def get_phase(self):
    """
    多频相移解包裹主流程
    
    处理所有频率的相位图，分别对水平和垂直方向进行解包裹
    
    返回:
        unwarp_phase_y: 垂直方向展开的相位图
        unwarp_phase_x: 水平方向展开的相位图
        ratio: 相位质量图(基于调制度与偏移比)
    """
    # 1. 解码各个频率的相位
    # 解码垂直方向的三个频率的相位
    phase_1y,amp1_y,offset1_y = self.decode_phase(image=self.images[0:4])   # 高频
    phase_2y,amp2_y,offset2_y = self.decode_phase(image=self.images[4:8])   # 中频
    phase_3y,amp3_y,offset3_y = self.decode_phase(image=self.images[8:12])  # 低频

    # 解码水平方向的三个频率的相位
    phase_1x,amp1_x,offset1_x = self.decode_phase(image=self.images[12:16]) # 高频
    phase_2x,amp2_x,offset2_x = self.decode_phase(image=self.images[16:20]) # 中频
    phase_3x,amp3_x,offset3_x = self.decode_phase(image=self.images[20:24]) # 低频

    # 2. 外差法获取逐级展开的相位差
    # 计算垂直方向相位差
    phase_12y = self.phase_diff(phase_1y,phase_2y)  # 频率1和2的差异
    phase_23y = self.phase_diff(phase_2y,phase_3y)  # 频率2和3的差异
    phase_123y = self.phase_diff(phase_12y,phase_23y) # 差异的差异(等效最低频)

    # 计算水平方向相位差
    phase_12x = self.phase_diff(phase_1x,phase_2x)  # 频率1和2的差异
    phase_23x = self.phase_diff(phase_2x,phase_3x)  # 频率2和3的差异
    phase_123x = self.phase_diff(phase_12x,phase_23x) # 差异的差异(等效最低频)

    # 3. 平滑最低等效频率相位以提高鲁棒性
    phase_123y = cv.GaussianBlur(phase_123y,(3,3),0)
    phase_123x = cv.GaussianBlur(phase_123x,(3,3),0)

    # 4. 相位展开流程 - 自底向上展开
    # 使用最低等效频率相位(phase_123y/x)展开中等频率相位差(phase_12y/x和phase_23y/x)
    unwarp_phase_12_y = self.unwarpphase(phase_123y,phase_12y,1,self.f12)
    unwarp_phase_23_y = self.unwarpphase(phase_123y,phase_23y,1,self.f23)

    unwarp_phase_12_x = self.unwarpphase(phase_123x,phase_12x,1,self.f12)
    unwarp_phase_23_x = self.unwarpphase(phase_123x,phase_23x,1,self.f23)
    
    # 5. 使用展开后的中等频率相位差(unwarp_phase_12_y/x和unwarp_phase_23_y/x)
    # 展开中频相位(phase_2y/x)
    unwarp_phase2_y_12 = self.unwarpphase(unwarp_phase_12_y,phase_2y,self.f12,self.f[1])
    unwarp_phase2_y_23 = self.unwarpphase(unwarp_phase_23_y,phase_2y,self.f23,self.f[1])

    unwarp_phase2_x_12 = self.unwarpphase(unwarp_phase_12_x,phase_2x,self.f12,self.f[1])
    unwarp_phase2_x_23 = self.unwarpphase(unwarp_phase_23_x,phase_2x,self.f23,self.f[1])

    # 6. 取两个展开路径的平均值以提高鲁棒性
    unwarp_phase_y = (unwarp_phase2_y_12+unwarp_phase2_y_23)/2
    unwarp_phase_x = (unwarp_phase2_x_12+unwarp_phase2_x_23)/2

    # 7. 归一化相位结果
    unwarp_phase_y/=self.f[1]  # 以中频为基准归一化
    unwarp_phase_x/=self.f[1]  # 以中频为基准归一化

    # 8. 计算相位质量，使用调制度/偏移比值的最小值
    ratio_x = np.min([amp1_x/offset1_x,amp2_x/offset2_x,amp3_x/offset3_x],axis=0)
    ratio_y = np.min([amp1_y/offset1_y,amp2_y/offset2_y,amp3_y/offset3_y],axis=0)

    ratio = np.min([ratio_x,ratio_y],axis=0)  # 取水平和垂直方向的最小值作为最终质量图

    return unwarp_phase_y,unwarp_phase_x,ratio
```

### 3. 三频外差法关键步骤解析

#### 3.1 相位差计算

通过`phase_diff`方法计算不同频率相位图之间的差值：

```python
def phase_diff(self,image1,image2):
    """
    计算两个相位图之间的差值
    
    实现了外差法的核心操作，确保相位差在[0,1]范围内
    
    参数:
        image1: 高频相位图
        image2: 低频相位图
        
    返回:
        result: 两相位图的归一化差值
    """
    result = image1-image2       # 计算相位差
    result[result<0]+=1          # 处理负值，保证结果在[0,1]区间
    return result
```

#### 3.2 相位展开

使用`unwarpphase`方法基于低频参考相位展开高频相位：

```python
def unwarpphase(self,reference,phase,reference_f,phase_f):
    """
    基于低频参考相位展开高频相位
    
    参数:
        reference: 参考(低频)相位图
        phase: 需展开的(高频)包裹相位图
        reference_f: 参考相位的频率
        phase_f: 需展开相位的频率
        
    返回:
        unwarp_phase: 展开后的相位图
    """
    # 根据频率比例缩放参考相位
    # 低频相位乘以频率比得到高频相位的估计值
    temp=phase_f/reference_f*reference
    
    # 计算整数条纹序数k并应用
    # 用缩放后的低频相位减去高频包裹相位，四舍五入得到整数条纹序数
    test = np.round(temp-phase)
    unwarp_phase=phase+np.round(temp-phase)

    # 高斯滤波去噪，检测错误跳变点
    gauss_size=(5,5)
    unwarp_phase_noise = unwarp_phase-cv.GaussianBlur(unwarp_phase,gauss_size,0)
    unwarp_reference_noise = temp-cv.GaussianBlur(temp,gauss_size,0)

    # 检测异常点：展开相位的噪声明显大于参考相位的噪声
    order_flag = np.abs(unwarp_phase_noise)-np.abs(unwarp_reference_noise)>0.25
    
    # 修复异常跳变点
    unwarp_error = unwarp_phase[order_flag]
    unwarp_error_direct = unwarp_phase_noise[order_flag]
    # 根据噪声方向调整条纹序数
    unwarp_error[unwarp_error_direct>0]+=1  # 正向噪声增加一个周期
    unwarp_error[unwarp_error_direct<0]-=1  # 负向噪声减少一个周期

    # 应用修复结果
    unwarp_phase[order_flag]=unwarp_error

    return unwarp_phase
```

## 四、三频外差法解相位的实现流程

三频外差法相位解包裹的完整流程如下：

1. **获取三个频率的包裹相位**：
   - 高频相位：提供高精度但有大量相位跳变
   - 中频相位：精度适中，相位跳变较少
   - 低频相位：精度低但无相位跳变或很少

2. **计算频率之间的相位差**：
   - 计算高频与中频的相位差：phase_12 = phase_1 - phase_2
   - 计算中频与低频的相位差：phase_23 = phase_2 - phase_3
   - 计算相位差之间的差：phase_123 = phase_12 - phase_23（相当于最低等效频率）

3. **自底向上的相位展开**：
   - 使用最低等效频率相位(phase_123)展开中频相位差(phase_12和phase_23)
   - 使用展开后的中频相位差展开中频相位(phase_2)
   - 这种自底向上的策略有效减少了错误累积

4. **多路径展开提高鲁棒性**：
   - 通过两个不同的展开路径（高-中频路径和中-低频路径）获得两个展开结果
   - 取平均值作为最终结果，有效减少随机误差

5. **相位质量评估**：
   - 使用调制度/偏移比作为相位质量指标
   - 取水平和垂直方向相位质量的最小值作为最终质量评估

## 五、总结

三频外差法相位解包裹算法是结构光三维重建中的重要步骤，通过使用不同频率的条纹图像，实现了从包裹相位到绝对相位的转换。该方法具有以下优点：

1. **抗噪能力强**：通过多频段冗余信息提高了解包裹的鲁棒性
2. **自动修复异常点**：检测并修复相位跳变错误，提高结果准确性
3. **不依赖空间连续性**：可以处理物体表面不连续或有遮挡的情况
4. **适用于动态场景**：所有计算都是基于每个像素独立进行的，适合快速采集

`get_abs_phase.py`中的实现同时处理了水平和垂直方向的条纹图像，能够获得更加全面和准确的三维信息，为后续的三维重建提供了可靠的相位数据。
